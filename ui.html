<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        background-color: #FFFFFF;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        padding: 20px;
    }

    .title {
        font-size: 14px;
        font-weight: 500;
        color: rgba(0, 0, 0, 0.85);
        margin-bottom: 8px;
    }

    .description {
        font-size: 12px;
        font-weight: 400;
        color: rgba(0, 0, 0, 0.65);
        margin-bottom: 16px;
        line-height: 1.5;
    }

    .config-label {
        font-size: 12px;
        font-weight: 400;
        color: rgba(0, 0, 0, 0.65);
        margin-bottom: 8px;
    }

    .textarea {
        width: 100%;
        min-height: 100px;
        padding: 8px 12px;
        border: 1px solid rgba(0, 0, 0, 0.15);
        border-radius: 4px;
        font-size: 12px;
        font-family: inherit;
        resize: vertical;
        outline: none;
        transition: border-color 0.2s;
        margin-bottom: 16px;
    }

    .textarea:focus {
        border-color: #2E74FF;
    }

    .submit-button {
        width: 100%;
        height: 28px;
        background-color: #2E74FF;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 400;
        color: #FFFFFF;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .submit-button:hover {
        background-color: #1e5fcc;
    }

    .submit-button:active {
        background-color: #1550b3;
    }

    .submit-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    .message {
        font-size: 12px;
        font-weight: 400;
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 12px;
        display: none;
    }

    .message.show {
        display: block;
    }

    .message.loading {
        background-color: #E6F4FF;
        color: #2E74FF;
    }

    .message.success {
        background-color: #F6FFED;
        color: #52C41A;
    }

    .message.error {
        background-color: #FFF2E8;
        color: #FF7A45;
    }
</style>

<h1 class="title">文本填充</h1>
<p class="description">请描述需要填充的文本，将自动生成符合描述的内容</p>
<label class="config-label">文本描述</label>
<textarea class="textarea" id="textInput" placeholder="请输入文本描述..."></textarea>
<div class="message" id="message"></div>
<button class="submit-button" id="submitBtn">提交</button>

<script>
    const textInput = document.getElementById('textInput');
    const submitBtn = document.getElementById('submitBtn');
    const message = document.getElementById('message');

    // 显示消息
    function showMessage(text, type) {
        message.textContent = text;
        message.className = 'message show ' + type;
    }

    // 隐藏消息
    function hideMessage() {
        message.className = 'message';
    }

    // Vercel 代理 API URL
    const PROXY_URL = 'https://textfill-ten.vercel.app/api/qwen-proxy';

    // 调用 API 生成文本（在 UI 中调用，因为可以使用 fetch）
    async function callQwenAPI(description, count) {
        try {
            console.log('UI: 开始调用代理API:', PROXY_URL);
            console.log('UI: 请求参数:', { description, count });
            
            console.log('UI: 发送fetch请求...');
            
            // 创建 AbortController 用于超时控制
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 60000); // 60秒超时
            
            let response;
            try {
                response = await fetch(PROXY_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        description: description,
                        count: count
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
            } catch (fetchError) {
                clearTimeout(timeoutId);
                if (fetchError.name === 'AbortError') {
                    throw new Error('请求超时，请检查网络连接或稍后重试');
                }
                throw fetchError;
            }
            
            console.log('UI: 收到响应:', response.status, response.statusText);
            console.log('UI: 响应头:', response.headers);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('UI: API响应错误:', response.status, errorText);
                let errorData = {};
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    errorData = { error: errorText };
                }
                throw new Error(errorData.error || `API请求失败: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('UI: API返回数据:', data);
            
            if (!data.success || !data.texts || !Array.isArray(data.texts)) {
                throw new Error(data.error || 'API返回数据格式错误');
            }
            
            if (data.texts.length < count) {
                throw new Error(`生成的文本数量不足，需要${count}个，实际生成${data.texts.length}个`);
            }
            
            console.log('UI: 成功获取文本:', data.texts);
            return data.texts;
        } catch (error) {
            console.error('UI: 调用代理API失败:', error);
            if (error.message.includes('Failed to fetch') || error.message.includes('timeout') || error.message.includes('ERR_CONNECTION_TIMED_OUT')) {
                throw new Error('无法连接到服务器，请检查网络连接或稍后重试。如果问题持续，可能是 Vercel 代理服务器无法访问。');
            }
            throw error;
        }
    }

    // 提交按钮点击事件
    submitBtn.addEventListener('click', function() {
        const text = textInput.value.trim();
        if (!text) {
            showMessage('请输入文本描述', 'error');
            return;
        }

        // 禁用按钮并显示加载状态
        submitBtn.disabled = true;
        showMessage('正在处理...', 'loading');

        // 向主线程发送消息
        parent.postMessage({ pluginMessage: { type: 'submit', text: text } }, '*');
    });

    // 接收来自主线程的消息
    window.onmessage = (event) => {
        console.log('UI: 收到window.onmessage事件:', event);
        console.log('UI: event.data:', event.data);
        console.log('UI: event.data.pluginMessage:', event.data.pluginMessage);
        
        // 主线程发送的消息可能在 event.data 中，也可能在 event.data.pluginMessage 中
        let msg = event.data.pluginMessage || event.data;
        if (!msg) {
            console.log('UI: 无法提取消息，忽略');
            return;
        }
        
        console.log('UI: 提取的消息:', msg);
        console.log('UI: 消息类型:', msg.type);

        // 处理 API 请求（主线程请求 UI 调用 API）
        if (msg.type === 'request-api') {
            console.log('UI: 收到API请求:', msg);
            showMessage(`正在生成${msg.count}个文本...`, 'loading');
            
            callQwenAPI(msg.description, msg.count)
                .then(texts => {
                    console.log('UI: API调用成功，发送结果给主线程');
                    // 将结果发送回主线程
                    parent.postMessage({ 
                        pluginMessage: { 
                            type: 'api-response', 
                            texts: texts 
                        } 
                    }, '*');
                })
                .catch(error => {
                    console.error('UI: API调用失败:', error);
                    // 发送错误给主线程
                    parent.postMessage({ 
                        pluginMessage: { 
                            type: 'api-response', 
                            error: error.message || 'API调用失败' 
                        } 
                    }, '*');
                });
            return;
        }

        submitBtn.disabled = false;

        if (msg.type === 'loading') {
            showMessage(msg.message || '正在处理...', 'loading');
        } else if (msg.type === 'success') {
            showMessage(msg.message || '操作成功', 'success');
            // 3秒后隐藏成功消息
            setTimeout(() => {
                hideMessage();
            }, 3000);
        } else if (msg.type === 'error') {
            showMessage(msg.message || '操作失败', 'error');
        }
    };
</script>
